# PaperSpecimen

## Descrizione Progetto
**Cornice digitale da frigo** per M5Paper che visualizza glifi tipografici casuali da font TrueType/OpenType. Si aggiorna automaticamente ogni 15 minuti con font e glifi random, funzionando come specimen tipografico sempre diverso. Ottimizzato per massima durata batteria (30-44 giorni) con deep sleep intelligente.

## Hardware
- **Device**: M5Paper (ESP32-based e-ink display, versione standard non S3)
- **Display**: 960x540 pixels, 4.7" e-ink, orientamento VERTICALE (540x960)
- **Storage**: microSD card FAT32 per font files
- **Batteria**: 1150mAh LiPo 4.35V
- **Pulsanti utilizzati**:
  - BtnL/BtnR (rotella laterale su/giÃ¹): cambio font/peso mantenendo stesso glifo
  - BtnP (rotella pressione centrale): nuovo glifo casuale con font corrente
- **Componenti disabilitati** (per risparmio batteria):
  - Touchscreen GT911
  - WiFi
  - Bluetooth
  - Sensore temperatura/umiditÃ  SHT30
  - Alimentazione sensori esterni

## Stack Tecnologico
- **Platform**: ESP32 (espressif32)
- **Framework**: Arduino
- **IDE**: VSCode + PlatformIO
- **Librerie principali**:
  - M5EPD v0.1.5 (include FreeType per rendering font TTF)
  - SD library (per accesso microSD)
  - esp_sleep.h (per deep sleep e timer wakeup)

## Configurazione PlatformIO
File: `platformio.ini`
```ini
[env:m5paper]
platform = espressif32
board = m5stack-fire
framework = arduino
board_build.partitions = default.csv
build_flags =
    -DBOARD_HAS_PSRAM
    -mfix-esp32-psram-cache-issue
lib_deps =
    m5stack/M5EPD@^0.1.5
```

## Git Versioning

### Branch Structure
- **`master`**: PaperSpecimen v1.0 - Versione stabile (cornice digitale da frigo)
- **`feature/outline-mode`**: PaperSpecimen v2.0 - WIP (modalitÃ  outline vettoriale)

### Comandi Utili
```bash
# Torna alla versione stabile v1.0
git checkout master

# Torna alla versione sperimentale v2.0
git checkout feature/outline-mode

# Vedi differenze tra versioni
git diff master feature/outline-mode

# Lista commit (savestate)
git log --oneline --graph --all
```

### Savestate Workflow
```bash
# Salva stato attuale (dopo modifiche importanti)
git add .
git commit -m "Descrizione modifiche"

# Torna a uno stato precedente (CTRL+Z infinito)
git log --oneline  # Trova commit hash (es: a1b2c3d)
git reset --hard a1b2c3d

# ATTENZIONE: reset --hard CANCELLA modifiche non committate
```

---

## Stato Progetto: âœ… v1.0 COMPLETATO | ðŸš§ v2.0 WIP

### v1.0 Build Info (master branch)
- **Compilazione**: SUCCESS
- **Flash utilizzata**: 84.7% (1,109,529 / 1,310,720 bytes)
- **RAM utilizzata**: 1.1% (49,792 bytes / 4,521,984 bytes)
- **File binario**: `.pio/build/m5paper/firmware.bin`

### v1.0 FunzionalitÃ  (COMPLETATE)
âœ… Scansione automatica font dalla microSD (skip file nascosti macOS `._*`)
âœ… Caricamento dinamico font con FreeType
âœ… Rendering glifi **375px** con anti-aliasing 16-bit
âœ… Dual render cache (24px per label, 375px per glifo)
âœ… Navigazione font con rotella (su/giÃ¹ mantiene glifo)
âœ… Generazione random glifi da 9 Unicode ranges comuni
âœ… Refresh intelligente (5 partial + 10s threshold per auto full refresh)
âœ… Display info: nome font (top), Unicode codepoint (bottom)
âœ… **Deep sleep intelligente** (~1mA dopo 10s idle)
âœ… **Auto-wake ogni 15 minuti** con ESP32 timer
âœ… **Font + glifo random** ad ogni auto-wake
âœ… **Wake rapido su button press** (no boot screen)
âœ… **Low battery protection** (<5% mostra icona e shutdown)
âœ… **Power optimization** (tutti i sensori inutilizzati disabilitati)
âœ… Gestione errori con feedback visivo

---

## ðŸš§ v2.0 Obiettivi: ModalitÃ  Outline Vettoriale

### Feature Target
**Toggle bitmap â†” outline** con long press pulsante centrale (BtnP)

### ModalitÃ  Outline: Cosa Visualizzare
- **Contorni vettoriali**: outline paths del glifo (linee sottili 1-2px)
- **On-curve points**: cerchi pieni neri (~6-8px) - punti di ancoraggio
- **Off-curve points**: cerchi vuoti con bordo (~6-8px) - control points BÃ©zier
- **Construction lines**: linee tratteggiate sottili tra control points e anchor points
- **Info tecnica**:
  - Numero di contours (es. "Contours: 2")
  - Numero totale punti (es. "Points: 47")
  - Tipo curve (Quadratic/Cubic BÃ©zier)
- **Background**: bianco o grigio chiaro per contrasto
- **Footer**: stesso layout v1.0 (font name, Unicode codepoint)

### Accuratezza
- âœ… **100% fedele ai dati font originali** (no approssimazioni)
- âœ… Usa FreeType `FT_Outline_Decompose` per accesso diretto ai vettori
- âœ… Coordinate precise derivate da FT_Face (stesso scaling 375px del bitmap)
- âœ… Tipo curva corretto: quadratic (TrueType) vs cubic (PostScript/OpenType)

### ðŸ”§ Workflow e Protocollo Flash/Debug

**IMPORTANTE**: Problemi cavo USB richiedono workflow manuale.

**Protocollo compilazione/flash**:
1. âœ… Claude compila: `pio run`
2. âŒ Claude NON flasha mai
3. ðŸ“¤ Claude fornisce comando flash
4. ðŸ”Œ User esegue flash manualmente (retry multipli se necessario)
5. ðŸ“¥ User riporta output a Claude

**Comandi da usare** (forniti da Claude, eseguiti da User):
```bash
# Flash firmware
pio run --target upload

# Monitor seriale (debug output)
screen /dev/cu.usbserial-* 115200

# Esci da screen: CTRL+A poi K, poi Y
# Oppure: killall screen (da altro terminale)
```

### ðŸŽ¯ Step Incrementali Implementazione v2.0

**Filosofia**: "Compila, testa, committa" - Mai piÃ¹ di 50-100 righe senza test.

#### Step 1: **Proof of Concept - Accesso FT_Face** â­ CRITICO
- [ ] Aggiungi funzione test per accesso `FT_Face`
- [ ] Stampa su Serial: numero contours e punti del glifo corrente
- [ ] NESSUN rendering, solo lettura dati
- [ ] **Test successo**: `Serial: "Glyph 'A' has 2 contours, 47 points"`
- [ ] **Commit**: `feat: Add FT_Face access test (proof of concept)`

#### Step 2: **Parsing Outline â†’ Serial Debug**
- [ ] Implementa callback `FT_Outline_Decompose`
- [ ] Stampa ogni segmento su Serial (MoveTo/LineTo/ConicTo/CubicTo)
- [ ] Storage temporaneo in arrays globali
- [ ] NESSUN rendering, solo parsing + debug
- [ ] **Test successo**: Serial mostra tutti i segmenti del glifo
- [ ] **Commit**: `feat: Implement outline parsing with FreeType callbacks`

#### Step 3: **Rendering Minimale - Solo Contorni**
- [ ] Usa dati parsati per disegnare solo linee (contorni)
- [ ] NO punti, NO construction lines
- [ ] Test su glifo semplice (I, L)
- [ ] **Test successo**: Display mostra outline riconoscibile
- [ ] **Commit**: `feat: Add basic outline rendering (contours only)`

#### Step 4: **Aggiungi On-Curve e Off-Curve Points**
- [ ] Disegna cerchi pieni per on-curve points
- [ ] Disegna cerchi vuoti per off-curve points
- [ ] Opzionale: construction lines tratteggiate
- [ ] **Test successo**: Outline completo con punti distinguibili
- [ ] **Commit**: `feat: Add control points visualization`

#### Step 5: **Toggle Interaction - Long Press**
- [ ] Long press detection (800ms threshold)
- [ ] Enum `ViewMode { BITMAP, OUTLINE }`
- [ ] Toggle mode al long press + re-render
- [ ] **Test successo**: Short press â†’ random, Long press â†’ switch view
- [ ] **Commit**: `feat: Add bitmap/outline toggle with long press`

#### Step 6: **Persistenza ViewMode in RTC Memory**
- [ ] Aggiungi `viewMode` a `rtcState`
- [ ] Salva prima di sleep, ripristina al wake
- [ ] **Test successo**: Mode sopravvive a sleep/wake e auto-wake 15min
- [ ] **Commit**: `feat: Persist view mode across sleep/wake cycles`

#### Step 7: **Polish e Edge Cases**
- [ ] Info overlay (Contours: N, Points: M)
- [ ] Gestione glifi senza outline (spazi, ecc)
- [ ] Ottimizzazioni rendering se lento
- [ ] **Commit**: `polish: Add info overlay and error handling`

---

### Obiettivi Implementazione v2.0 (Dettaglio Fasi)

#### ðŸŽ¯ Fase 1: Accesso FT_Face (PRIORITY)
- [ ] Accesso a `FT_Face` da `M5EPD_Canvas` (protetto in `TFT_eSPI::_font_face`)
- [ ] Soluzioni possibili:
  - [ ] **Opzione A**: Friend function (richiede modifica M5EPD library)
  - [ ] **Opzione B**: Public accessor (richiede modifica library)
  - [ ] **Opzione C**: Inheritance workaround (estendi M5EPD_Canvas)
  - [ ] **Opzione D**: Memory hack (cast pointer, no library mod)
- [ ] Verifica accesso FT_Face funzionante (test su Serial)

#### ðŸŽ¯ Fase 2: Parsing Outline con FreeType
- [ ] Implementa callback functions per `FT_Outline_Decompose`:
  - [ ] `outlineMoveTo(FT_Vector* to, void* user)` - inizio contour
  - [ ] `outlineLineTo(FT_Vector* to, void* user)` - segmento lineare
  - [ ] `outlineConicTo(FT_Vector* control, FT_Vector* to, void* user)` - quadratic BÃ©zier
  - [ ] `outlineCubicTo(FT_Vector* c1, FT_Vector* c2, FT_Vector* to, void* user)` - cubic BÃ©zier
- [ ] Struttura dati per storage outline:
  - [ ] Array di punti on-curve (anchor points)
  - [ ] Array di punti off-curve (control points)
  - [ ] Array di segmenti (type: line/conic/cubic)
  - [ ] Contatori: num_contours, num_points
- [ ] Coordinate scaling da font units a 375px display space
- [ ] Test parsing: stampa outline su Serial per verifica

#### ðŸŽ¯ Fase 3: Rendering Outline su Display
- [ ] Funzione `drawOutline()` per visualizzazione:
  - [ ] Draw contour paths (linee sottili 1-2px, colore nero 15)
  - [ ] Draw on-curve points (cerchi pieni 6-8px)
  - [ ] Draw off-curve points (cerchi vuoti con bordo)
  - [ ] Draw construction lines (linee tratteggiate tra control/anchor)
- [ ] Ottimizzazione rendering per e-ink:
  - [ ] Usa `canvas.drawLine()` per paths
  - [ ] Usa `canvas.fillCircle()` / `canvas.drawCircle()` per points
  - [ ] Color mapping: 0=bianco, 15=nero, 8=grigio (construction lines)
- [ ] Info overlay:
  - [ ] "Contours: N" top-right
  - [ ] "Points: M" sotto contours
  - [ ] Footer esistente (font name, Unicode)

#### ðŸŽ¯ Fase 4: Toggle Interaction (Long Press)
- [ ] Detect long press su BtnP (GPIO38):
  - [ ] Threshold: 800-1000ms pressione
  - [ ] Differenzia da short press (glifo random)
- [ ] State machine: `enum ViewMode { BITMAP, OUTLINE }`
- [ ] Toggle logic:
  - [ ] Long press â†’ switch mode
  - [ ] Clear canvas
  - [ ] Render con mode attuale
  - [ ] Full refresh (GC16) per pulizia
- [ ] RTC state: salva `viewMode` in `rtcState` per persistenza wake

#### ðŸŽ¯ Fase 5: Testing e Refinement
- [ ] Test su glifi semplici (A-Z): contours puliti
- [ ] Test su glifi complessi (@, &, ÃŸ): molti punti e curve
- [ ] Test ghosting outline mode (linee sottili piÃ¹ sensibili)
- [ ] Test toggle rapido bitmap â†” outline (full refresh overhead)
- [ ] Verifica memoria: outline parsing non deve saturare heap
- [ ] Serial debug: log num_contours, num_points, curve types

#### ðŸŽ¯ Fase 6: Polish e Ottimizzazioni
- [ ] Anti-aliasing linee outline (se possibile con M5EPD primitives)
- [ ] Color scheme alternativo: outline mode con background grigio chiaro?
- [ ] Feedback visivo durante toggle (es. "Switching to outline mode...")
- [ ] Documentazione: aggiorna README e .claude.md con istruzioni v2.0
- [ ] Batteria: misura impatto outline parsing su consumi (probabilmente trascurabile)

### Technical Challenges Previste
- **EASY**: Callback functions FreeType (API ben documentato)
- **EASY**: Rendering primitives (linee, cerchi giÃ  disponibili in M5EPD)
- **MEDIUM**: Accesso FT_Face protetto (richiede workaround)
- **MEDIUM**: Long press detection (timing + debouncing)
- **MEDIUM**: Coordinate scaling da font units a pixels (matrix transform)
- **COMPLEX**: Outline rendering performante (molti drawLine su e-ink puÃ² essere lento)

### Effort Estimate
- **Tempo stimato**: 3-5 ore (se tutto va liscio)
- **Codice stimato**: 250-400 righe (parsing + rendering + interaction)
- **Rischio**: MEDIO (accesso FT_Face Ã¨ il punto critico)

### Use Case Professionale
Target utente: **Type designer, Typographer, Font enthusiast**
- âœ… Vedere costruzione reale del glifo (non approssimazione)
- âœ… Confrontare strategie design tra font (minimal points vs dettagliati)
- âœ… Capire come curve sono costruite (smooth vs sharp corners)
- âœ… Specimen tecnico oltre che visivo

### Durata Batteria Stimata
**30-44 giorni** con:
- Auto-wake ogni 15 minuti (96 eventi/giorno)
- Uso manuale 1-2 volte/giorno
- Deep sleep ~1mA
- Consumi auto-wake: ~13.3mAh/giorno
- Consumi totali: ~26-38mAh/giorno

## Come Usarlo

### Setup MicroSD
1. Formatta microSD in **FAT32**
2. Crea cartella `/fonts` nella root
3. Copia file `.ttf` o `.otf` nella cartella fonts
4. Inserisci microSD nell'M5Paper

Esempio struttura:
```
/
â””â”€â”€ fonts/
    â”œâ”€â”€ Helvetica-Regular.ttf
    â”œâ”€â”€ Helvetica-Bold.ttf
    â”œâ”€â”€ ABCDinamo-Regular.ttf
    â””â”€â”€ YourFont.otf
```

### Aggiornamento Font su MicroSD
**IMPORTANTE**: I font vengono scansionati solo al cold boot, non ad ogni wake.

**Per aggiungere/rimuovere/modificare font**:
1. Rimuovi microSD (anche con dispositivo in deep sleep)
2. Modifica i font nella cartella `/fonts`
3. Reinserisci microSD nell'M5Paper
4. **Premi reset fisico sul retro del dispositivo**
5. Il dispositivo ri-scansiona tutti i font e riparte

**PerchÃ© serve il reset**:
- La scansione SD avviene solo in `setup()` (cold boot)
- Ad ogni auto-wake (15 min) non viene ri-scansionata per risparmiare batteria
- Senza reset, il dispositivo continuerebbe a usare la lista di font vecchia

### Compilazione e Upload
```bash
# Compila
pio run

# Upload su M5Paper
pio run --target upload

# Monitor seriale (debug)
pio device monitor -b 115200
```

## Comportamento e Regole

### 1. Cold Boot (Reset fisico o prima accensione)
**Trigger**: Reset button sul retro + power button centrale
- Mostra schermata "PaperSpecimen, Booting..."
- Inizializza WiFi OFF, Bluetooth OFF, Sensori OFF
- Scansiona font dalla microSD
- Carica primo font disponibile
- Mostra glifo casuale
- Entra in modalitÃ  normale

### 2. ModalitÃ  Normale (Dispositivo attivo)
**Controlli manuali**:
- **BtnL (giÃ¹)**: Font precedente, **stesso glifo**
- **BtnR (su)**: Font successivo, **stesso glifo**
- **BtnP (centro)**: Glifo random, **stesso font**

**Regole refresh**:
- Partial refresh (UPDATE_MODE_GL16) per ogni cambio
- Auto full refresh dopo 5 partial OPPURE dopo 10s dal primo partial
- Full refresh pulisce ghosting e resetta contatori

**Timer idle**:
- Dopo 10 secondi dall'ultimo full refresh senza input â†’ **Deep Sleep**

### 3. Deep Sleep Mode
**Stato**:
- ESP32 in deep sleep (~1mA consumo)
- Display IT8951 in StandBy (mantiene immagine visibile)
- GPIO2 in hold (mantiene alimentazione)
- RTC BM8563 attivo ma non usato
- Stato salvato in RTC memory (font index, glyph codepoint)

**Wake sources**:
1. **ESP32 timer**: esattamente 15 minuti
2. **GPIO38 (button centrale)**: pressione utente

### 4. Auto-Wake (Timer 15 minuti)
**Comportamento**:
- Wake cause: `ESP_SLEEP_WAKEUP_TIMER`
- **NO boot screen**
- Controlla batteria (se <5% â†’ Low Battery Shutdown)
- Genera **font completamente random** (diverso dal precedente)
- Genera **glifo completamente random**
- Renderizza con partial refresh
- Dopo 10s (o 5 partial/10s timer) â†’ full refresh automatico
- Torna in deep sleep dopo 10s idle

**Scopo**: Cornice da frigo che cambia specimen automaticamente

### 5. Wake Manuale (Button Press)
**Comportamento**:
- Wake cause: `ESP_SLEEP_WAKEUP_EXT0` (GPIO38)
- **NO boot screen**
- Controlla batteria (se <5% â†’ Low Battery Shutdown)
- **Ripristina stato precedente** (stesso font, stesso glifo)
- Renderizza esattamente quello che c'era prima
- ModalitÃ  normale attiva
- Pulsanti funzionanti normalmente

**Scopo**: Riprendi esattamente dove avevi lasciato

### 6. Low Battery Protection (<5%)
**Trigger**: Batteria voltage < 3345mV (5% carica)
**Controllo**: Solo al wake da deep sleep (ogni 15 min o button press)

**Comportamento**:
1. Schermo cleared completamente (full refresh)
2. Disegna icona batteria scarica stilizzata:
   - Rettangolo 120x60px con tip 10x20px (stile AA battery)
   - Barra sottile 6px (5% indicator)
   - Testo "LOW BATTERY" e "Please charge device"
3. Mostra per 2 secondi
4. **Shutdown completo** (`M5.shutdown()`)
   - Solo RTC rimane alimentato (~1.5ÂµA)
   - Display mantiene icona visibile (e-ink persistence)

**Riattivazione**: Solo con power button dopo ricarica USB â†’ Cold boot

### 7. Gestione Errori
**SD Card Error**:
- Messaggio "SD CARD ERROR"
- Istruzioni per inserire microSD
- Device halted (loop infinito)

**No Fonts Found**:
- Messaggio "NO FONTS FOUND"
- Istruzioni per aggiungere .ttf/.otf in /fonts
- Device halted

**Font Load Error**:
- Messaggio "FONT LOAD ERROR"
- Suggerimento controllare serial output
- Device halted

## Note Tecniche

### Display E-Paper IT8951 (16 livelli di grigio)
- **Risoluzione**: 960x540 pixels (540x960 vertical), 4.7"
- **Grayscale**: 16 livelli (4-bit) per anti-aliasing ottimale
- **Orientamento**: `SetRotation(90)` per verticale

**Update Modes Utilizzati**:
| Mode | Ghosting | Tempo | Livelli Grigio | Uso |
|------|----------|-------|----------------|-----|
| `UPDATE_MODE_GL16` | Medium | 450ms | 16 | Partial refresh normale |
| `UPDATE_MODE_GC16` | Very Low | 450ms | 16 | Full refresh pulizia ghosting |

**Strategia Refresh**:
1. Partial (GL16) per cambio glifo/font rapido
2. Full (GC16) automatico dopo 5 partial o 10s
3. Minimizza flickering, massimizza qualitÃ 

### Font Rendering
**Formati supportati**: TrueType (.ttf), OpenType (.otf)

**Dual Cache System**:
```cpp
canvas.createRender(24, 64);    // Labels: 24px, 64 glyphs cache
canvas.createRender(375, 12);   // Main glyph: 375px, 12 glyphs cache
```

**Rendering Pipeline**:
1. `canvas.loadFont(path, SD)` - carica font da microSD
2. `canvas.createRender(size, cache)` - setup renderer + cache
3. `canvas.setTextSize(size)` - switch tra 24px e 375px
4. `canvas.drawString(text, x, y)` - rendering con FreeType
5. `canvas.pushCanvas(0, 0, mode)` - push to display

**Color Mapping** (4-bit grayscale):
- `0` = bianco (background)
- `15` = nero (text)
- `12` = grigio (icone batteria)

### Unicode Ranges per Random Glyph
9 ranges comuni (biased verso caratteri piÃ¹ probabili):
```cpp
{0x0041, 0x005A, "Latin Uppercase"},    // A-Z
{0x0061, 0x007A, "Latin Lowercase"},    // a-z
{0x0030, 0x0039, "Digits"},             // 0-9
{0x0021, 0x002F, "Basic Punctuation 1"},// !"#$%&'()*+,-./
{0x003A, 0x0040, "Basic Punctuation 2"},// :;<=>?@
{0x005B, 0x0060, "Basic Punctuation 3"},// [\]^_`
{0x007B, 0x007E, "Basic Punctuation 4"},// {|}~
{0x00A1, 0x00BF, "Latin-1 Punctuation"},// Â¡-Â¿
{0x00C0, 0x00FF, "Latin-1 Letters"},    // Ã€-Ã¿ accented
```

### Power Management Dettagliato

**Inizializzazione Ottimizzata**:
```cpp
M5.begin(false, true, true, false, true);
// touchEnable=false       â†’ Touch disabled
// SDEnable=true           â†’ SD enabled (font loading)
// SerialEnable=true       â†’ Serial debug enabled
// BatteryADCEnable=false  â†’ Battery ADC on-demand only
// I2CEnable=true          â†’ I2C for RTC (unused but init)

WiFi.mode(WIFI_OFF);      // WiFi OFF
btStop();                 // Bluetooth OFF
M5.disableEXTPower();     // External sensors OFF (SHT30, etc)
```

**Deep Sleep Entry**:
```cpp
M5.EPD.StandBy();                          // Display controller standby
gpio_hold_en(GPIO_NUM_2);                  // Hold GPIO2 HIGH
gpio_deep_sleep_hold_en();                 // Enable hold in deep sleep
esp_sleep_enable_ext0_wakeup(GPIO_NUM_38, LOW); // Button wake
esp_sleep_enable_timer_wakeup(900000000ULL);    // 15min timer
esp_deep_sleep_start();                    // Enter deep sleep
```

**Wake Detection**:
```cpp
esp_sleep_wakeup_cause_t cause = esp_sleep_get_wakeup_cause();

if (cause == ESP_SLEEP_WAKEUP_TIMER) {
    // Auto-wake: random font + random glyph
} else if (cause == ESP_SLEEP_WAKEUP_EXT0) {
    // Button wake: restore state
} else {
    // Cold boot: show boot screen
}
```

**Consumi Misurati/Stimati**:
- Cold boot: ~160mA per 3-5 secondi
- Active mode: ~160mA (rendering + SD access)
- Deep sleep: ~0.5-1mA (ESP32 + voltage regulators)
- Shutdown: ~1.5ÂµA (solo RTC, dopo low battery)

### RTC Memory State Persistence
```cpp
RTC_DATA_ATTR struct {
    bool isValid;                  // State validity flag
    int currentFontIndex;          // Font index (0-N)
    uint32_t currentGlyphCodepoint;// Glyph Unicode (e.g., 0x0041)
} rtcState;
```
Sopravvive a deep sleep, perso solo su reset hardware.

### Pulsanti M5Paper
- **BtnL**: GPIO (rotella giÃ¹)
- **BtnR**: GPIO (rotella su)
- **BtnP**: GPIO38 (rotella centro, anche wake pin)
- Debounce: 300ms delay software
- Wake trigger: GPIO38 LOW (button press)

## Output Seriale (Debug)
Monitor seriale 115200 baud mostra:
```
=== PaperSpecimen Cold Boot ===
WiFi and Bluetooth disabled
External sensors power disabled
Scanning for fonts...
  Found: /fonts/Helvetica-Bold.ttf
Total fonts found: 5

=== Loading font: /fonts/Helvetica-Bold.ttf ===
Creating render cache for labels (size=24, cache=64)...
Creating render cache for glyph (size=375, cache=12)...
Font loaded successfully

Rendered: A (U+0041) with font Helvetica-Bold

=== Setup Complete ===

>>> Preparing for deep sleep...
State saved: font=0, glyph=U+0041
Wake sources configured: GPIO38 (button) + Timer (15min)
>>> Entering deep sleep now...

=== PaperSpecimen Auto-Wake (Timer) ===
Woke by ESP32 timer after 15 minutes
Battery level: 87.3%
Auto-wake: Generating random font + glyph
Random font selected: 3/5
Rendered: Ã¨ (U+00E8) with font ABCDinamo-Regular
```

## Troubleshooting

### Auto-wake non funziona
- âŒ RTC alarm non funziona con deep sleep + GPIO hold
- âœ… Usa ESP32 timer wakeup (`esp_sleep_enable_timer_wakeup()`)
- Verifica serial output: deve mostrare "ESP_SLEEP_WAKEUP_TIMER"

### Ghosting eccessivo
- Aumenta `MAX_PARTIAL_BEFORE_FULL` (attualmente 5)
- Riduci `FULL_REFRESH_TIMEOUT_MS` (attualmente 10000ms)

### Batteria si scarica velocemente
- Verifica serial: deve entrare in deep sleep dopo 10s
- Check: tutti i sensori disabilitati in setup
- Misura: ~1mA in sleep Ã¨ normale, >10mA indica problema

### Display rimane bianco dopo wake
- Color mapping invertito: usa `fillCanvas(0)` + `setTextColor(15)`
- Verifica dual cache creation (24px + 375px)

### Font non caricati
- Controlla file nascosti macOS (`._*`) - vengono skippati
- Verifica formato FAT32 su microSD
- Serial mostra "Font load error" con dettagli

## Crediti
- **Hardware**: M5Stack M5Paper
- **Librerie**: M5EPD (include FreeType)
- **Framework**: Arduino ESP32 via PlatformIO
- **Progetto**: PaperSpecimen - Typographic Specimen Frame

## Licenza
Open source - usa come preferisci
